// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Orgs.WithOrg {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/orgs/{org}/repos`
        public let path: String

        /// List organization repositories
        ///
        /// Lists repositories for the specified organization.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#list-organization-repositories)
        public func get(parameters: GetParameters? = nil) -> Request<[OctoKit.MinimalRepository]> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "repos/list-for-org")
        }

        public enum GetResponseHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetParameters {
            public var type: `Type`?
            public var sort: Sort?
            public var direction: Direction?
            public var perPage: Int?
            public var page: Int?

            public enum `Type`: String, Codable, CaseIterable {
                case all
                case `public`
                case `private`
                case forks
                case sources
                case member
                case `internal`
            }

            public enum Sort: String, Codable, CaseIterable {
                case created
                case updated
                case pushed
                case fullName = "full_name"
            }

            public enum Direction: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public init(type: `Type`? = nil, sort: Sort? = nil, direction: Direction? = nil, perPage: Int? = nil, page: Int? = nil) {
                self.type = type
                self.sort = sort
                self.direction = direction
                self.perPage = perPage
                self.page = page
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(page, forKey: "page")
                return encoder.items
            }
        }

        /// Create an organization repository
        ///
        /// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
        /// 
        /// **OAuth scope requirements**
        /// 
        /// When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
        /// 
        /// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        /// *   `repo` scope to create a private repository
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#create-an-organization-repository)
        public func post(_ body: PostRequest) -> Request<OctoKit.Repository> {
            Request(method: "POST", url: path, body: body, id: "repos/create-in-org")
        }

        public enum PostResponseHeaders {
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostRequest: Encodable {
            /// The name of the repository.
            public var name: String
            /// A short description of the repository.
            public var description: String?
            /// A URL with more information about the repository.
            public var homepage: String?
            /// Whether the repository is private.
            public var isPrivate: Bool
            /// Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.
            public var visibility: Visibility?
            /// Either `true` to enable issues for this repository or `false` to disable them.
            public var hasIssues: Bool
            /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
            public var hasProjects: Bool
            /// Either `true` to enable the wiki for this repository or `false` to disable it.
            public var hasWiki: Bool
            /// Either `true` to make this repo available as a template repository or `false` to prevent it.
            public var isTemplate: Bool
            /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
            public var teamID: Int?
            /// Pass `true` to create an initial commit with empty README.
            public var isAutoInit: Bool
            /// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
            public var gitignoreTemplate: String?
            /// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
            public var licenseTemplate: String?
            /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
            public var allowSquashMerge: Bool
            /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
            public var allowMergeCommit: Bool
            /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
            public var allowRebaseMerge: Bool
            /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
            public var allowAutoMerge: Bool
            /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
            public var deleteBranchOnMerge: Bool

            /// Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.
            public enum Visibility: String, Codable, CaseIterable {
                case `public`
                case `private`
                case `internal`
            }

            public init(name: String, description: String? = nil, homepage: String? = nil, isPrivate: Bool? = nil, visibility: Visibility? = nil, hasIssues: Bool? = nil, hasProjects: Bool? = nil, hasWiki: Bool? = nil, isTemplate: Bool? = nil, teamID: Int? = nil, isAutoInit: Bool? = nil, gitignoreTemplate: String? = nil, licenseTemplate: String? = nil, allowSquashMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowRebaseMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil) {
                self.name = name
                self.description = description
                self.homepage = homepage
                self.isPrivate = isPrivate ?? false
                self.visibility = visibility
                self.hasIssues = hasIssues ?? true
                self.hasProjects = hasProjects ?? true
                self.hasWiki = hasWiki ?? true
                self.isTemplate = isTemplate ?? false
                self.teamID = teamID
                self.isAutoInit = isAutoInit ?? false
                self.gitignoreTemplate = gitignoreTemplate
                self.licenseTemplate = licenseTemplate
                self.allowSquashMerge = allowSquashMerge ?? true
                self.allowMergeCommit = allowMergeCommit ?? true
                self.allowRebaseMerge = allowRebaseMerge ?? true
                self.allowAutoMerge = allowAutoMerge ?? false
                self.deleteBranchOnMerge = deleteBranchOnMerge ?? false
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case description
                case homepage
                case isPrivate = "private"
                case visibility
                case hasIssues = "has_issues"
                case hasProjects = "has_projects"
                case hasWiki = "has_wiki"
                case isTemplate = "is_template"
                case teamID = "team_id"
                case isAutoInit = "auto_init"
                case gitignoreTemplate = "gitignore_template"
                case licenseTemplate = "license_template"
                case allowSquashMerge = "allow_squash_merge"
                case allowMergeCommit = "allow_merge_commit"
                case allowRebaseMerge = "allow_rebase_merge"
                case allowAutoMerge = "allow_auto_merge"
                case deleteBranchOnMerge = "delete_branch_on_merge"
            }
        }
    }
}
